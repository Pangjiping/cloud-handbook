# **golang内存分配器**

## **1. 设计原理**

内存管理一般包含三个不同的组件，分别是用户程序(Mutator)、分配器(Allocator)和收集器(Collector)，当用户程序申请内存时，它会通过内存分配器申请新的内存，而分配器会负责从堆中初始化相应的内存区域。

![img](https://img.draveness.me/2020-02-29-15829868066411-mutator-allocator-collector.png)

### **1.1 分配方法**
---

编程语言的内存分配器一般包含两种分配方法，一种是线性分配器(Sequential Allocator, Bump Allocator)，另一种是空闲链表分配器(Free-List Allocator)，这两种分配方法有着不同的实现机制和特性。

**线性分配器**

线性分配是一种高效的内存分配方法，但是有着较大的局限性。当我们使用线性分配器时，只需要在内存中维护一个指向内存特定位置的指针，如果用户程序向分配器申请内存，分配器只需要检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置

![img](https://img.draveness.me/2020-02-29-15829868066435-bump-allocator.png)

虽然线性分配器实现为它带来了较快的执行速度以及较低的实现复杂度，但是线性分配器无法在内存被释放时重用内存。如下图所示，如果已经分配的内存被释放，线性分配器无法重新利用红色的内存

![img](https://img.draveness.me/2020-02-29-15829868066441-bump-allocator-reclaim-memory.png)

因为线性分配器具有上述特性，所以需要与合适的垃圾回收算法配合使用，例如：标记压缩（Mark-Compact）、复制回收（Copying GC）和分代回收（Generational GC）等算法，它们可以通过拷贝的方式整理存活对象的碎片，将空闲内存定期合并，这样就能利用线性分配器的效率提升内存分配器的性能了。

因为线性分配器需要与具有拷贝特性的垃圾回收算法配合，所以 C 和 C++ 等需要直接对外暴露指针的语言就无法使用该策略。

**空闲链表分配器**

空闲链表分配器（Free-List Allocator）可以重用已经被释放的内存，它在内部会维护一个类似链表的数据结构。当用户程序申请内存时，空闲链表分配器会依次遍历空闲的内存块，找到足够大的内存，然后申请新的资源并修改链表：

![img](https://img.draveness.me/2020-02-29-15829868066446-free-list-allocator.png)

因为不同的内存块通过指针构成了链表，所以使用这种方式的分配器可以重新利用回收的资源，但是因为分配内存时需要遍历链表，所以它的时间复杂度是 𝑂(𝑛)。空闲链表分配器可以选择不同的策略在链表中的内存块中进行选择，最常见的是以下四种：

* 首次适应（First-Fit）- 从链表头开始遍历，选择第一个大小大于申请内存的内存块；
* 循环首次适应（Next-Fit）- 从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块；
* 最优适应（Best-Fit）- 从链表头遍历整个链表，选择最合适的内存块；
* 隔离适应（Segregated-Fit）- 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块；

Go 语言使用的内存分配策略与第四种策略有些相似，我们通过下图了解该策略的原理：

![img](https://img.draveness.me/2020-02-29-15829868066452-segregated-list.png)

如上图所示，该策略会将内存分割成由 4、8、16、32 字节的内存块组成的链表，当我们向内存分配器申请 8 字节的内存时，它会在上图中找到满足条件的空闲内存块并返回。隔离适应的分配策略减少了需要遍历的内存块数量，提高了内存分配的效率。

<br>

<br>