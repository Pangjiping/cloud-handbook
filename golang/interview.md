# **Golang**

## **基础问题**
---

### **golang错误处理的方式**
---
最常见的就是使用err!=nil来做错误处理，但是对于api层来讲这样的错误处理方式会使代码显得臃肿，可以采用的一种方式是在service层注入一个errChan来做错误信息的接收，可以大大简化api层的错误处理逻辑，同时在并发执行时也不必关注goroutine中的错误信息。

<br>

### **golang协程的概念以及GMP调度器**
---
使用 go func()来开启一个协程，子协程可以与父协程工过sync.WaitGroup来做同步等待，在协程内一般会使用defer recover()来避免panic。GMP调度器分为以下三个部分：G-goutinue、M-CPU线程、P-调度器。

某个线程尝试创建一个新的G，那么这个G就会被安排到这个线程的本地队列中，如果本地队列满了，就会被分配到全局队列。

尝试获取当前线程的M，如果无法获取，就会从空闲的M列表中找一个，如果空闲列表也没有M，那么会创建一个M，然后与G队列和P绑定。

GMP的调度机制主要是以下这两个：work stealing和hand off机制

![img](https://www.topgoer.com/static/7.1/gmp/13.jpg)

​[参考链接](https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html)

<br>

### **goroutine的通信方式，管道的基本实现**
---
golang的理念是使用共享变量来代替共享内存的方式，channel就是goroutine的标准通信方式，可以避免外部加锁引起的线程阻塞和数据竞争问题。

channel的基本实现是一个带锁的环形队列，FIFO，另外<-和->的goutinue使用两个list来保存，在channel阻塞时，进程会阻塞在list中。

channel分为带缓冲区和不带缓冲区的channel，带缓冲区的channel数据是不保证同步的。另外向channal读写数据需要注意以下事项：

- 关闭的channel不能写，panic
- 关闭的channel可以读，可以用ok来判断channel缓冲区是否还有值
- 对于关闭的channel，可以用for range来读channel，未关闭不推荐使用，会阻塞
- 带缓冲的channel，缓冲区满阻塞发送方，缓冲区空阻塞接收方
- 不带缓冲的channel，无接收方时发送方阻塞，这时会报死锁，缓冲区无数据阻塞接收方

<br>

### **golang中解决解决数据竞争的方式，并发控制的方式**
---
最基本的方式是使用锁机制，golang中存在两种基本的锁：互斥锁和读写锁，不推荐使用互斥锁。另外好像1.18还引进了一个非阻塞的tryLock机制，不会阻塞线程。golang中避免加锁最简单的方式就是使用channel做数据暂存，加速goroutine的并发程度。

golang中并发控制的方式可以有以下几种：

- waitGroup，这种方式只能使主线程同步等待，而无法控制线程并发数量
- 通过channel通知来实现并发，可以利用带缓冲的channel来做并发控制，提前指定最大并发量，类似于消息通知
- 通过context来实现并发控制，主要用于kill子线程
- 自己实现一个并发的限流器，其基本理念还是使用channel，注意原子操作

<br>

### **golang context的基本使用**
---
在goroutine构成的树形结构中对信号进行同步以减少计算资源的浪费是context最大的作用。每一个context.Context都会从最顶层的goroutine一层一层传递给最下层。context.Context可以在上层goroutine执行出现错误时，将信号及时同步给下层。

- 使用context同步信号
- 默认上下文
- 取消信号用于取消子协程的执行状态 context.WithCancel
- 传值方法 context.WithValue
​[参考链接](https://www.cnblogs.com/aganippe/p/16022679.html)

<br>

### **golang中sync.Map的基本实现**
---
sync.Map是线程安全的，其基本实现理念就是读写分离，存在两个哈希表，write和read，读时有可能是无锁读的，但要注意使用场景，sync.Map只适用于读多写少的场景，因为write会向read表做大量的数据迁移。写多的场景可以使用map+mutex来实现，或者使用开源选择。
[参考链接](https://cloud.tencent.com/developer/article/1915119)

<br>

### **golang中的defer调用栈**
---
return语句先执行，defer后执行。在遇到panic时，会遍历本协程的defer调用链，并执行defer函数。在行过程中遇到recover会停止panic，否则继续panic输出到stderr。defer最大的作用就是panic之后仍然有效，所以defer可以保证在进程panic之后一些资源仍然可以被释放，从而避免一些异常情况。

<br>

### **golang中的反射基本使用案例**
---
- 做结构体tag的解析，解析自定义tag
- 做通用数据的处理工作，有些类似于范型的理念
- 做结构体的赋值、DeepEqual()判断、数据类型判断、零值判断等

<br>

### **golang中切片的结构**
---
一个切片在运行时由指针、长度和容量三部分组成。

指针指向切片元素对应的底层数组元素的地址；长度对应切片中元素的数目，长度不能超过容量；容量一般是从切片的开始位置到底层数组的结尾位置的长度。

![img](https://img2022.cnblogs.com/blog/2794988/202203/2794988-20220326211723824-446981699.png)

[参考链接](https://www.cnblogs.com/aganippe/p/16061071.html)

<br>

### **golang垃圾回收三色标记法**
---
go 1.3-标记清除法，go 1.5-三色标记法，go-1.8 三色标记法+混合写屏障

- 标记清除法：分为两个阶段：标记和清除。标记阶段：从根对象出发寻找并标记所有存活的对象。清除阶段：遍历堆中的对象，回收未标记的对象，并加入空闲链表。缺点是需要暂停程序STW。
- 三色标记法：将对象标记为白色，灰色或黑色。白色：不确定对象（默认色）；黑色：存活对象。灰色：存活对象，子对象待处理。标记开始时，先将所有对象加入白色集合（需要STW）。首先将根对象标记为灰色，然后将一个对象从灰色集合取出，遍历其子对象，放入灰色集合。同时将取出的对象放入黑色集合，直到灰色集合为空。最后的白色集合对象就是需要清理的对象。这种方法有一个缺陷，如果对象的引用被用户修改了，那么之前的标记就无效了。因此Go采用了**写屏障技术**，当对象新增或者更新会将其着色为灰色。

一次完整的GC分为四个阶段：

1. 准备标记（需要STW），开启写屏障。
2. 开始标记
3. 标记结束（STW），关闭写屏障
4. 清理（并发）

基于插入写屏障和删除写屏障在结束时需要STW来重新扫描栈，带来性能瓶颈。**混合写屏障**分为以下四步：

1. GC开始时，将栈上的全部对象标记为黑色（不需要二次扫描，无需STW）；
2. GC期间，任何栈上创建的新对象均为黑色
3. 被删除引用的对象标记为灰色
4. 被添加引用的对象标记为灰色

总而言之就是确保黑色对象不能引用白色对象，这个改进直接使得GC时间从 2s降低到2us。

[参考链接](https://www.cnblogs.com/aganippe/p/16022689.html)

<br>

### **golang中的init()函数**
---

init()函数会在main()函数之前执行，可以用于一些全局变量的初始化工作和配置加载工作

<br>

### **golang中的内存逃逸分析**
---

Go和C++不同，Go局部变量会进行**逃逸分析**。如果**变量离开作用域后没有被引用**，则**优先**分配到栈上，否则分配到堆上。那么如何判断是否发生了逃逸呢？

```bash
$ go build -gcflags '-m -m -l' xxx.go
```

关于逃逸的可能情况：变量大小不确定，变量类型不确定，变量分配的内存超过用户栈最大值，暴露给了外部指针。

<br>

### **goroutine的内存泄漏**
---
在Go中内存泄露分为暂时性内存泄露和永久性内存泄露。

**暂时性内存泄露**

- 获取长字符串中的一段导致长字符串未释放
- 获取长slice中的一段导致长slice未释放
- 在长slice新建slice导致泄漏

string相比切片少了一个容量的cap字段，可以把string当成一个只读的切片类型。获取长string或者切片中的一段内容，由于新生成的对象和老的string或者切片共用一个内存空间，会导致老的string和切片资源暂时得不到释放，造成短暂的内存泄漏

**永久性内存泄露**

- goroutine永久阻塞而导致泄漏
- time.Ticker未关闭导致泄漏
- 不正确使用Finalizer（Go版本的析构函数）导致泄漏

<br>


### **golangOOP设计实现**
---
封装 - struct

继承 - 匿名结构体

多态 - interface{}

<br>


### **golang的内存管理系统**
---
golang内存管理基本是参考tcmalloc来进行的。go内存管理本质上是一个内存池，只不过内部做了很多优化：自动伸缩内存池大小，合理的切割内存块。

一些基本概念：
页Page：一块8K大小的内存空间。Go向操作系统申请和释放内存都是以页为单位的。
span : 内存块，一个或多个连续的 page 组成一个 span 。如果把 page 比喻成工人， span 可看成是小队，工人被分成若干个队伍，不同的队伍干不同的活。
sizeclass : 空间规格，每个 span 都带有一个 sizeclass ，标记着该 span 中的 page 应该如何使用。使用上面的比喻，就是 sizeclass 标志着 span 是一个什么样的队伍。
object : 对象，用来存储一个变量数据内存空间，一个 span 在初始化时，会被切割成一堆等大的 object 。假设 object 的大小是 16B ， span 大小是 8K ，那么就会把 span 中的 page 就会被初始化 8K / 16B = 512 个 object 。所谓内存分配，就是分配一个 object 出去。

**mheap**

一开始go从操作系统索取一大块内存作为内存池，并放在一个叫mheap的内存池进行管理，mheap将一整块内存切割为不同的区域，并将一部分内存切割为合适的大小。

![img](https://pic3.zhimg.com/80/v2-05f622a5c88a9a9456d43ee301622582_1440w.jpg)

mheap.spans ：用来存储 page 和 span 信息，比如一个 span 的起始地址是多少，有几个 page，已使用了多大等等。

mheap.bitmap 存储着各个 span 中对象的标记信息，比如对象是否可回收等等。

mheap.arena_start : 将要分配给应用程序使用的空间。

**mcentral**

用途相同的span会以链表的形式组织在一起存放在mcentral中。这里用途用**sizeclass**来表示，就是该span存储哪种大小的对象。

找到合适的 span 后，会从中取一个 object 返回给上层使用。

**mcache**

为了提高内存并发申请效率，加入缓存层mcache。每一个mcache和处理器P对应。Go申请内存首先从P的mcache中分配，如果没有可用的span再从mcentral中获取。

<br>


### **golang的select机制**
---
- 当多个条件同时被满足时，select会随机执行一个分支
- select一般不会永远阻塞，会配合超时定时器来使用
- 一个nil channel存在于select中时，select将永远不会被执行

​[参考链接](https://www.cnblogs.com/aganippe/p/16099532.html)

<br>


### **golang竞态检测**
---
两个goroutine访问无锁访问共享资源，可以用命令检测

```bash
$ go run -race xx.go
```

<br>

### **golang常见的后端框架**
---
- Viper： 配置管理
- Gin：轻量级web框架
- Gorm：操作mysql
- Beego：web框架，集成orm，MVC设计

<br>


### **golang连接池设计**
---

连接池是为了更高效的利用资源，防止资源的重复创建和删除，同时连接池也需要设计自动释放和自动注册的机制

<br>


## **细节问题**
---

### **面向对象编程时需要注意的问题？**
---

注意在使用自定义数据结构实现interface{}时，初始化方法的返回值严禁写成具体类，一是不满足OOP的规范，二是当返回nil时用一个interface{}来接收此nil值，其结果并不是nil，而是一个指向具体类的空指针，因为interface{}的内存布局是4字节的数据类型+4字节的指针。

<br>


### **slice何时发生内存逃逸**
---
当在for循环中对slice进行append操作时，有可能该slice发生扩容从而逃逸到堆区，解决方案是在slice初始化时尽量确定其容量，map同理	

<br>


### **reflect可以导出unexported变量吗？为什么json.Marshal()不可以**
---
reflect可以导出非导出变量的数据，json包不导出是因为遵守go的设计规范，小写字母就是不可导出的	

<br>


### **如何将一个结构体转成map**
---
可以利用json包进行一次序列化和反序列化，但是这样可能会比较慢。合理的方式是利用反射和tag来做。

<br>


### **backend高并发设计需要注意什么问题**
---
注意控制并发程度，防止对请求借口造成不可控的压力，同时注意线程安全

<br>


### **函数返回局部变量的指针是否安全？为什么**
---
与C++不同，golang返回局部变量的指针是安全的，因为Go会进行逃逸分析，如果发现局部变量的作用域超过该函数则会把指针分配到堆区，避免内存泄漏。

<br>


### **两个nil值相等吗？**
---
nil是否相等取决于其数据类型，只有在数据类型相同时nil才会相等。

<br>