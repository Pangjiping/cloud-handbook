**contributed by @ophelia-E**

<br>

# 1.c++基础

### 1.1 c和c++区别

**c++面向对象，c面向过程**的结构化的编程语言

**c++中有类**的概念，c没有

**c++中有引用**的概念，c只有指针

**c++中有模板**，c中没有

**c++中有函数重载**，c中没有

**c++使用new delete**对内存分配的运算符，取代了**c的malloc和free**

c++可以随时定义函数声明函数，c中没有



### 1.2 指针和引用区别

指针保存的是指向对象的地址（**指针就是地址**），引用保存的是变量的别名（**引用就是起别名**）

指针在定义时没有要求（**为避免野指针还是尽量初始化**，引用在定义的时候必须初始化（**引用必须初始化**）

**指针可以改，引用不能改**

存在空指针，但不存在空引用

引用的创建不会调用类的拷贝构造函数



### 1.3 new/delete和malloc/free区别

**new是运算符**，malloc是库函数

**new可以重载**，malloc不能重载

new变量是数据类型，malloc变量是字节大小

**new可以调用构造函数**/delete可以调用析构函数，malloc/free不行

**new返回**的是指定对象的**指针**，malloc返回的是void*

**new**分配到内存不够时候不能扩容，malloc分配到内存不够时候能够扩容

new内存分配失败抛出bad_malloc，malloc内存分配失败返回NULL



### 1.4 volatile关键字

​	访问寄存器要比访问内存快，cpu会优先访问该数据在寄存器中的储存结果（但内存中的数据或许已经改变，而寄存器中还是原来的数据），为了避免这种情况，**将该变量声明为volatile，告诉cpu每次都去内存中读取数据**。

​	更多的可能是多线程并发访问共享变量的时候，一个线程改变了变量的值，怎样让改变后的值对其他线程可用

​	（一个参数可以既是const又是volatile的）



### 1.5 static关键字作用

**static类内声明，类外初始化**（因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。）

​		全局静态变量：静态存储区，整个程序运行期间都存在，在声明文件内有效，未初始化则初始化为0

​		局部静态变量：静态存储区，只在定义和调用他的函数体内可以访问，退出函数不会被销毁，再次进入还能使用，未初始化则初始化为0

​		静态函数：静态函数只是在声明他的文件中存在，不能被其他文件所用（默认extern）

​		类的静态成员：静态成员可以实现多个对象间的数据共享，而不只是某个对象的成员，对多个对象来说，静态数据成员储存在一处，供所有对象使用

​		类的静态函数：和类的静态成员一样，都是静态成员而不是对象成员，因此对静态成员的引用无需对象名，类static成员变量初始化在类外实现

​		在静态成员函数的实现中，不能直接引用类中的非静态成员，可以引用类中的静态成员（如果静态成员函数中要引用非静态成员，可以通过对象引用）



### 1.6 extern关键字作用

​		声明一个外部变量或外部函数



### 1.7 const

const修饰全局变量

const修饰局部变量

const修饰指针

const修饰指针指向的对象

const修饰引用做形参（防止在函数内部更改入参值）

const成员变量初始化 在构造函数的初始化列表里进行,构造函数内不行，不可以通过赋值来初始化（定义+赋值）

const修饰成员函数，说明该函数不应该修改非静态成员



### 1.8 define/const/inline区别

define仅仅是宏替换，不占用内存

const会占用内存

inline由编译器控制

宏不是函数，inline是函数

宏在定义时小心处理宏函数（把参数括起来



### 1.9 构造析构抛出异常

不要再析构函数中抛出异常（重新定义普通函数，或者trycatch

构造函数抛出异常，会无法调用析构，可能会产生内存泄漏



### 1.10 c++/c内存分配方式、堆栈区别

栈区（stack）：由编译器自动分配与释放，存放 运行时函数分配的局部变量、函数参数、返回数据、返回地址等，其操作类似于数据结构中的栈

堆区（heap）：一般由程序员分配，由程序员释放

全局区（静态static）：存放全局变量，静态数据，常量。程序结束后由系统释放

常量区（文字常量区）：存放常量字符串，程序结束后系统释放

代码区：存放函数体（类成员函数和全局区）的二进制代码

**三种内存分配方式**：

​	从静态储存区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在（全局变量，static）

​	在栈上创建：执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会被自动释放

​	从堆上分配：动态内存分配，自己delete



### 1.11 有哪些内存泄漏 如何判断 如何定位

内存泄漏：由于忽视或错误造成的程序未能释放但已经不再使用的情况，是程序分配某段内存后丢失了对此					内存块的控制，造成了内存浪费。



### 1.12 智能指针

能够处理资源泄露的问题

能够处理空悬指针的问题

能够处理隐晦的由异常造成的资源泄露



### 1.13 为什么需要动态分配内存

所有内存需求都是在程序执行之前通过定义所需的变量来确定的

但可能会存在 程序的内存需求只能在运行时才能确定的情况

例如：当需要的内存取决于用户的输入--->这时需要动态分配内存

动态分配内存的异常机制：

（分配失败抛出bad_alloc类型的异常）（分配失败时new返回空指针，程序继续）



### 1.14 c++新特性

nullptr ： 代替了NULL

auto：自动类型推导

decltype

unordered_map：无序容器，快查快删



### 1.15 c++中四种cast转换

四种类型： const_cast, static_cast, dynamic_cast,reinterpret_cast

const_cast：用于将const转成非const

ststic_cast：用于各种隐式转换，非const转const、void转指针、能用于多态向上转化，如果向下转不安全结果未知

dynamic_cast：用于动态类型转换，只能用于含有虚函数的类，用于类层次间的向上向下转化，只能转指针或者引用

​							向上转换：指的是子类向基类转换；向下转换：指的是基类向子类的转换

reinterpret_cast：几乎什么都可以转，但可能会出现问题



### 1.16 如何让一个类不实例化

1.定义为抽象的基类

2.构造函数设为private



### 1.17  智能指针会内存泄漏吗？如何解决

当两个对象互相使用一个shared_ptr变量指向对方时候，会造成循环引用，使得引用计数失效，从而内存泄漏。

为解决以上问题，引入weak_ptr，其构造函数不会修改引用计数值，不会对对象的内存进行管理，类似一个普通指针，但不指向引用计数的共享内存，可以检测到指向对象是否被释放，避免非法访问。

（父类有一个shared_ptr成员指向子类，若子类也有个shared_ptr成员指向父类，然后在实例化对象时，同时使用了智能指针a、b，又将a、b分别付给两个shared_ptr，从而就变成了循环引用）



### 1.18 编译的四个过程

![C++程序编译过程](https://img-blog.csdnimg.cn/582451a64b1f4755af1e5ca5a9506c28.png)

预处理器：引入头文件，宏替换，删除注释，从.cpp变.i

编译器：主要做词法、语法、语义分析等，在检查无误后，把代码翻译成汇编语言，从.i变.s（栈区是由编译器自动分配释放的）

汇编器：将汇编代码转变成cpu可以执行的指令(机器码010101文件) 从.s变.o（可重定向目标文件）

链接器：将不同的源文件产生的目标文件进行库链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接 



# 2 虚函数、类

### 2.1 面向对象三大特性

封装：把客观事物封装成抽象的类，类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的信息隐藏。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体，在一个对象内部，某些代码和数据可以是不能被外界访问的，通过这种方式，对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的更改，或者错误的使用。



继承：可以让某个类对象获得另一个类对象的属性。通过继承，可以使用现有的功能，并在无需重新编写原来功能的基础上进行扩展，通过继承创建的新类称之为“子类”或“派生类”，被继承的类称之为“父类”或“基类”。

​	实现继承：使用基类的属性和方法，无需额外编码；

​	接口继承：仅使用属性和方法的名称，子类提供实现



多态：是指一个类实例的相同方法在不同情形下有不同的表现形式。多态机制使得具有不同内部结构的对象可以共享相同的外部接口，虽然针对不同的对象具体操作不同，但通过一个公共的类，不同操作可以通过相同的方式调用

C++多态基于基于虚函数和虚继承，核心就是用一个通用基类的指针指向不同子类的实例。在内存中，通过“虚函数表”来实现子类方法的正确调用，通过“虚基类指针”保留一份基类的内存操作，避免冲突。

“虚”，成员函数是由静态的成员函数指针定义，虚函数是由一个虚函数表指向真正的函数指针，能够间接的确定想要的函数实现。

继承是将基类的内存空间拷贝一份，而虚继承则是用虚基类指针指向虚基类，避免基类重复。



### 2.2 c++如何创建一个类，使得其只能在堆or栈上存在

只能在堆上创建对象：将析构函数设置为私有

因为：c++是静态绑定语言，编译器管理栈上对象的生命周期，在为类分配栈空间时，会检查类的析构函数的访问性，如果是私有则不可访问，即不可在栈上创建对象。



### 2.3 必须在构造函数里初始化的成员函数有哪些

常量成员：因为常量成员只能初始化，不能赋值

引用类型：因为引用必须在定义时候初始化，不能赋值

没有默认构造函数的类，因为使用初始化列表可以不用调用默认构造函数初始化，直接调用拷贝构造函数



### 2.4 构造函数为什么不能是虚函数 析构函数为什么可以

虚函数的执行依赖于虚函数表，而虚函数表需要在构造函数中才能初始化，也就是说构造对象期间，虚函数表还没被初始化，所以构造函数无法为虚函数。

在类的继承中，如果有父类指针指向了子类，那么用父类指针delete时，如果不定义成虚函数，子类无法被析构。

构造函数不要调用虚函数。在父类构造的时候，虚函数是非虚的，不会走到子类中，采用的是静态绑定。

当我们构造子类对象，应该先调用父类的构造函数，去构造子类的父类部分，现在子类没有被构造没有初始化，如果父类的构造中调用了虚函数，如果可以的话就是调用了一个还没被初始化的对象，那是很危险的，所以c++中不可以在构造父类对象的时候调用子类的虚函数实现。

为了实现多态，进行动态绑定，将子类对象指针绑定到父类指针上，当对象销毁时，如果子类析构函数没有定义成虚函数，就会调用父类的析构函数，子类的数据无法被析构，造成内存泄漏。

如果要调用对象的析构函数，需要将该对象的析构函数定义为虚函数，销毁时候通过虚函数表找到对象的析构函数



### 2.5 重写重载与隐藏的区别

重载：的函数都在类内，是参数类型或者参数个数不一样，重载不关心返回值类型。

重写：是在子类中重新定义函数，函数名、返回值类型、参数类型、参数个数都与父类相同，并且父类是虚或纯虚函数。

隐藏：子类的函数屏蔽了与其同名的父类函数，只要同名，无论参数列表是否相同，父类函数都会被隐藏，有如下情况：

​		（1）参数列表不同，有无virtual，都会被隐藏

​		（2） 参数列表相同，无virtual，也会被隐藏



### 2.6 多态

多态是为了实现接口重用，父类引用子类的对象（将子类赋值给父类），进行动态绑定，不同的子类有不同的实现。

三条件：（继承关系）（子类重写父类函数）（父类指针或者引用指向子类对象）

c++的多态总结起来就是：在父类函数前加上virtual关键字，并在子类中重写该函数，在运行阶段会根据对象的实际类型调用相应函数，如果是子类的对象就调用子类函数，如果是父类对象就调用父类函数

（用virtual关键字声明的函数叫虚函数，虚函数也是类的成员函数）

（有虚函数的类，都有一个一维虚函数表，类的对象有一个指向虚函数表的虚指）

（虚表指针是函数指针数组）

（纯虚函数是虚函数后加上=0，该函数只有声明没有实现）

（抽象类是指包括至少一个纯虚函数的类）



### 2.7 多态与虚函数表

类的多态：同一种事物的多种形态

函数的多态性：一种调用，不同的执行效果

**虚函数表是针对类还是针对对象的？**虚函数表是针对类的，编译器为每一个类维护一个虚函数表

**同一个类的两个对象的虚函数表怎么维护？**虚函数表在编译时候已经确定，每个对象的首地址保存着该虚函数表的指针，而类对象的虚函数指针是在运行阶段确定的，这是多态的关键。



### 2.8 静态多态和动态多态（静态绑定和动态绑定）

多态分为静态多态和动态多态。

静态多态：在编译时候确定，重载和模板技术

动态多态：在程序运行时候确定，通过虚函数和继承关系确定



### 2.9 普通继承的构造析构顺序

最先被调用的构造函数的析构函数最后被调用（参考先进后出的栈）



### 2.10  深拷贝浅拷贝

浅拷贝导致的问题：student中构造函数有申请动态内存，导致s2复制s1时自动调用默认的构造函数，但在析构时候对同一个内存释放了两次

解决办法：对含有指针成员的对象进行拷贝时，必须要自定义拷贝构造函数，使拷贝后的对象指针成员有自己的内存空间，避免重复释放导致内存泄漏。

或者使用shared_ptr



### 2.11 面向对象

**面向对象**是相对于**面向过程**讲的，面向对象方法，把相关的数据和方法作为一个整体看待，从更高的层次来进行系统建模

（将程序和数据封装，提高了软件的重用性、灵活性、扩展性、安全性）

（继承可以建立类的层次或者等级）

（多态实现对同一操作做不同执行结果）



### 2.12 友元

友元访问类的非公有成员数据



# 3 STL

### 3.1 stl组成

三部分

容器：关联容器（map、set）顺序容器（vector、list）

算法

迭代器：类模板（不是指针！），模拟了指针的功能，通过重载指针的一些操作，遍历STL对象，封装了原生指针。迭代器使用后就被马上释放，不能继续使用，把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果



### 3.2 vector

**数组**是存放类型相同个对象的容器，数组大小确定，增删数组很麻烦，不允许整体的拷贝与赋值

**vector**是类模板，可自动扩容，增添元素很方便

数组：为内置的数据类型，存放在栈中，其内存的分配和释放完全由系统自动完成，大小固定，数组不能整体拷贝

vector：为内置的容器模板，存放在堆中，由STL库负责内存分配和释放，使用方便，大小可变，vector可以

执行效率的话是数组>vector的，因为vector有一个扩容机制会耗时。



### 3.3 vector的底层存储机制是如何实现的

vector就是一个动态数组，有指针指向一片连续的内存空间，当内存不够大时，会自动申请另一片更大的空间（1.5或2倍扩容），然后将原来数据拷贝过去，接着释放原来的那片空间，当释放或者删除里面数据时，其存储空间不释放仅仅是清空数据



### 3.4 vector的迭代器

vector的begin返回的是第一个元素的迭代器，end返回的是最后一个元素后面位置的迭代器  [ )

vector的插入操作可能会导致迭代器失效，因为vector的扩容机制（gcc的vector是2倍扩容、vs2013是1.5倍扩容），不是在原空间追加新的空间，而是重新配置一片大空间然后拷贝过来，所以迭代器会失效



### 3.5 vector与list

vector和数组类似，拥有连续的内存空间，起始地址不变，所以可以高效的进行随机存取，时间复杂度为o(1)，但因为内存空间连续，插入和删除的时间复杂度为o(n)，另外当数组内存不够，会重新申请一块内存空间进行拷贝。

list是由双向链表实现的，内存空间是不连续的，只能通过指针访问数据，list存取效率很低，时间复杂度为o(n)，不过可以高效的插入和删除。（尤其首部插入）

vector和list的迭代器都支持++，但是vector还支持+、+=、<



### 3.6 list的底层存储机制是如何实现的

以节点为单位存放数据，节点的地址在内存中不一定连续，每次插入或删除元素，都会配置或释放一个元素空间，（底层是双向链表）



### 3.7 list自带排序函数的排序原理

sort并不是简单的快速排序，它对普通的快速排序进行了优化，此外，它还结合了插入排序和堆排序。

系统会根据你的数据形式和数据量自动选择合适的排序方法，这并不是说它每次排序只选择一种方法，它是在一次完整排序中不同的情况选用不同方法，比如给一个数据量较大的数组排序，开始采用快速排序，分段递归，分段之后每一段的数据量达到一个较小值后它就不继续往下递归，而是选择插入排序，如果递归的太深，他会选择堆排序。



### 3.8 deque的底层机制是什么

deque动态的以分段连续空间组合而成，随时可以增加一段新的连续空间，并连接起来，不提供空间保留

除非必要，尽可能使用vector而不是deque

deque采用一块map（不是STL的map）作为主控，其为一小块连续空间，每个元素都是指针，指向另一段较大的连续空间（缓存区）（所以的确不是连续的，是由多段数组连接起来的）

deque迭代器包含：（cur迭代器当前所指元素）（first指缓冲区头）（last缓冲区尾）（node管控中心）



### 3.9 map、set、hash_map底层机制

map、set以红黑树为底层机制，红黑树是一种平衡二叉搜索树，自动排序效果不错

map、set插入删除效率比其他容器高，因为不需要内存拷贝、内存移动

map、set每次insert后，之前的迭代器不会失效，是因为插入只是节点指针变化，节点内存没有改变，迭代器可以理解为指向节点的指针，内存没变化，指针也不会变化

map、set在元素增大到万级别，查找时底层红黑树采用二分查找（时间复杂度logn）

hash_map以哈希表为底层，没有自动排序，能快速查找，每个元素有一个key一个value

（hash_map比map查找速度快，元素很多时候考虑hash_map）

hash_set以哈希表为底层，没有自动排序，能快速查找，只有一个key值

map的迭代器不能修改key，只能修改value，所以map的迭代器不是const或mutable



### 3.10 哈希表如何避免地址冲突

线性探测法：用哈希计算某个元素的插入位置，如果该位置已经被占用，继续往下寻找，直到找到可用空间

二次探测：如果计算出的位置被占用，尝试H+1(2)等

开链法：每个表格元素中维护一个list，哈希函数为我们分配一个list，然后在这个list中执行插入删除等操作



### 3.11 红黑树的性质

每个节点是红色或黑色的

根节点、叶子结点为黑色

如果节点为红色，子节点必须黑色

任一节点到NULL的任何路径，黑色节点数目都相同



### 3.12 vector、list、map、deque在使用erase后，迭代器的变化

vector、deque：序列式容器，内存分别是连续空间和分段连续空间，删除it后，后面的迭代器全部失效，此时it和后面的迭代器都会自动+1，指向被删除元素下一个元素

list：删除迭代器it时，后面的迭代器不会失效（链表），将前面元素和被删元素下一个元素连接即可

map：当前it失效，后面仍然有效

