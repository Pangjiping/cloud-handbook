# **C++**

## **基础问题**

### **new和malloc**
---
* new是运算符，malloc是c库函数
* new可以重载，malloc不能重载
* new变量是数据类型，malloc变量是字节大小
* new可以调用构造函数/delete可以调用析构函数，malloc/free不行
* new返回的是指定对象的指针，malloc返回的是void*
* new分配到内存不够时候不能扩容，malloc分配到内存不够时候能够扩容
* new内存分配失败抛出bad_malloc，malloc内存分配失败返回NULL

<br>

### **new operator和operator new**
---
new就是new operator，调用new的时候编译器做了三件事
* 用operator new()分配内存
* 调用构造函数
* 返回相应的指针

<br>

### **指针和引用**
---
* 引用必须初始化，指针可以不初始化，但是这是不合规范的
* int & const r = a;这样写错误，因为引用本身就不能改变指向，添加const多此一举
* 指针可以有多级但引用只能有一级。有int ** ,但是int &&并不代表引用的引用，而代表右值引用
* 指针的++，--代表下一个数据，引用的++，--代表数据本身的加减
* sizeof“引用”得到的是所指向的变量(对象)的大小，而sizeof“指针”得到的是指针本身的大小
* 当指针和引用作为函数参数的时候，指针传递参数会生成一个临时变量，引用传递的参数不会生成一个临时变量
指针传递的本质是值传递复制实参的地址到函数的栈中，然后在形参中对地址取值操作。而引用的形参是给实参起了一个别名，可以直接操控形参从而实现对实参的控制

<br>

### **重写、重载、隐藏**
---

**重载**

是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型（统一为void，否则报错）

**重写**

是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰

**隐藏**

是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。

**为什么可以实现重载**

因为C++在编译的时候会对函数进行重命名，保证函数名的唯一性，而重载函数的参数不同，就会被命名为不同的函数名。

**构造函数可以被重载么？析构函数呢？**

构造函数可以被重载，因为构造函数可以有多个且可以带参数。

析构函数不可以被重载，因为析构函数只能有一个，且不能带参数。

构造函数主要用来在创建对象时完成对对象属性的一些初始化等操作, 当创建对象时, 对象会自动调用它的构造函数。一般来说, 构造函数有以下三个方面的作用:
- 给创建的对象建立一个标识符
- 为对象数据成员开辟内存空间
- 完成对象数据成员的初始化

<br>

### **构造函数和析构函数**
---
**构造函数**
* 构造函数可以有多个，并且可以被重载
* 构造函数主要用来在创建对象时完成对对象属性的一些初始化等操作, 当创建对象时, 对象会自动调用它的构造函数，一般来说，构造函数有以下三个方面的作用：
    * 给创建的对象建立一个标识符
    * 为对象数据成员开辟内存空间
    * 完成对象数据成员的初始化

**析构函数**
* 析构函数只能有一个，并且不能被重载，不能带参数
* 当析构函数是非虚函数时，主函数通过指针访问非虚函数时，编译器会根据指针的类型来确定要调用的函数；而指针是父类指针，所以调用父类的析构函数。析构函数必须是虚函数。因为如果不是虚函数，当在主函数中用父类的指针new出一个子类对象，最后析构的时候，只会调用父类析构函数而不会调用子类析构函数。而且如果不为虚函数，父类指针就不会调用子类成员函数。父类析构函数成为虚函数时，子类的析构函数会自动也变为虚函数。这个时候编译器会忽略指针的类型，而根据指针的指向来选择函数；也就是说，指针指向哪个类的对象就调用哪个类的函数。pb、pd 都指向了派生类的对象，所以会调用派生类的析构函数，继而再调用基类的析构函数
  
<br>

### **虚函数和纯虚函数**
---
* 纯虚函数声明如下： `virtual void funtion1()=0`; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用
* 虚函数声明如下：`virtual ReturnType FunctionName(Parameter)` 虚函数必须实现
* 对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定
* 实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定
* 虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数
* 在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的
* 友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题
* 析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数

<br>

### **多态与虚函数**
---
多态就是说同一个名字的函数可以有多种不同的功能。分为编译时的多态和运行时的多态。编译时的多态就是函数重载，包括运算符重载，编译时根据实参确定调用哪个函数。运行时的多态则和虚函数、继承有关。

**多态的底层实现**
* 利用虚函数表，先构建一个基类，然后在基类的构造函数中会建立虚函数表，也就是一个储存虚函数地址的数组，内存地址的前四个字节保存指向虚函数表的指针，然后当多个子类继承父类之后，主函数中可以通过父类指针调用子类的继承函数
* 虚函数表属于类，也属于它的子类等各种派生类。虚函数表由编译器在编译时生成，保存在.rdata只读数据段

**子类的多态函数是怎么被调用的？**

因为每个子类都继承并设置了自己的虚函数表，每次用用父类指针创建新子类时就会出现，从而最终调用自己的表

**怎么知道多态时，指向哪个虚函数？**

定义的父类指针new出哪个子类就是指向哪个子类的虚函数。

**对象怎么找到对应的虚函数表？**

( *( *(p+0) + 0 ) )(p); p是父类指针，p+0是指针vfptr，该指针指向虚函数表的首地址。所以*(p+0)即虚函数表的地址，( *(p+0) + 0 )就是要找的虚函数的地址，+0代表该虚函数在表中的偏移量。( *( *(p+0) + 0 ) )(p)表示对该函数的调用

**虚函数表的结构是怎样的？**

虚函数表是一个函数指针数组，数组里存放的都是函数指针，指向虚函数所在的位置。 对象调用虚函数时，会根据虚指针找到虚表的位置，再根据虚函数声明的顺序找到虚函数在数组的哪个位置，找到虚函数的地址，从而调用虚函数

![img](https://pic3.zhimg.com/80/v2-dfe4aefdee7e06cf3151b57492ed42a2_1440w.jpg)

**父类的构造函数中是否可以调用虚函数？**

可以。不过调用会屏蔽多态机制，最终会把基类中的该虚函数作为普通函数调用，而不会调用派生类中的被重写的函数
* 这是因为在定义子类对象的时候，会先调用父类的构造函数，而此时虚函数表以及子类函数还没有被初始化
* 为了避免调用到未初始化的内存，C++标准规范中规定了在这种情况下，即在构造子类时调用父类的构造函数，而父类的构造函数中又调用了虚成员函数，这个虚成员函数即使被子类重写，也不允许发生多态的行为。所以使用的是静态绑定，调用了父类的函数

**构造函数可以是虚函数吗？**

不可以，因为虚函数存在的唯一目的就是为了多态。而子类并不继承父类的构造函数，构造函数是创建对象时自己主动调用的，不可能被继承，所以没有使父类构造函数变成虚函数的必要。另外，父类在构造函数中创建虚函数表，实例化类对象，如果构造函数成为虚函数，那么因为类对象没有实例化导致不可能后续出现虚函数

**静态函数可以是虚函数么？为什么？**
* static成员不属于任何对象实例，所以即使加上了virtual也没有任何意义
* 静态与非静态成员函数之间有一个主要的区别：静态成员函数没有this指针，无法访问vptr，不能访问vtable

**虚函数的安全性问题**

可以通过虚函数表，让父类指针访问子类的自有虚函数。这带来一定的安全问题。另外，即使父类的虚函数是私有函数或者保护函数，仍然可以通过虚函数表访问，带来一定的安全问题

<br>

### **static关键字**
---
* 生命周期是在整个程序运行内
* 内存分配在全局区
* static类内声明，类外初始化

<br>

### **const关键字**
---
* 全局const和局部const生命周期不同
* const成员函数(const的作用：说明其不会修改数据成员)任何不会修改数据成员的函数都应该声明为const 类型

<br>

### **vector**
---
Vector扩容就是重新申请一段更长的连续内存空间并把以前的数据移动过去，释放以前的内存空间。以前的迭代器都会失效。一般用VS扩容都是扩容现有容器容量的2倍，有的是1.5倍

**vector的内部实现**

vector是一个类，它里面有三个指针myfirst,mylast,myend.分别表示首地址，元素容量地址，容器容量地址。通过这三个指针分别表示容器的所有操作

![img](https://img-blog.csdn.net/20160223191226316)

**reserve和resize的区别是什么？**

reserve只是开辟空间并不创建元素。而resize重新开辟空间并自动初始化元素。

**迭代器失效**

就是比如vector容器扩容的时候，释放了原来的内存空间，导致原来的迭代器都失效不能用了。

迭代器失效就是因为扩容，删除元素等缘故，导致原先容器的空间变化，进而导致迭代器（begin()和end()）发生了变化，从而失效

<br>

### **强制类型转换**
---
* static_cast<>: 可以将值从一种数值类型转换为另一种数值类型
* dynamic_cast<>
* const_cast<>: 改变值为 const 或 volatile，其语法与dynamic_cast<>运算符相同
* reinterpret_cast<>: 有点危险
<br>

### **auto和decltype**
---
auto在 C++11 里最多的使用场景就是作为自动类型推导符号。
这里将举例`auto`和`decltype`的组合使用
当我们在写函数模板时，如果函数需要返回值，这是我们是无法确定应该返回的类型是什么的，这时候就可以采用下面这种写法：
```c++
template<class T1, class T2>
auto gt(T1 x, T2 y) -> decltype (x+y)
{
    ...
    return x+y;
}
```
<br>

### **lambda表达式**
---
lambda表达式的函数签名如下:
```c++
[capture list] (params list) mutable exception-> return type { function body }
```
* capture list: 捕获外部变量列表
* params list: 形参列表
* mutable指示符: 用来说明是否可以修改捕获的变量
* exception: 异常设定
* return type: 返回类型
* function body: 函数体

推荐阅读: https://www.cnblogs.com/DswCnblog/p/5629165.html

<br>

### **内联函数**
---
`inline`关键字

如果一个函数是内联函数，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。

在类定义中定义的函数都是内联函数，即使没有`inline`说明符。

```c++
inline int Max(int x, int y)
{
   return (x > y)? x : y;
}
```

引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：
* 在内联函数内不允许使用循环语句和开关语句
* 内联函数的定义必须出现在内联函数第一次调用之前
* 类结构中所在的类说明内部定义的函数是内联函数

<br>

## **细节问题**

### **const和define**
---
* const限定符可以明确指明变量的类型
* 可以使用C++的作用域规则将定义限制在特点的函数或文件中
* 可以将const用于更复杂的数据结构中，比如函数的形参定义等等

<br>