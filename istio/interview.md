# **istio**

## **istio的基本概念**
---

istio是由Google、IBM和Lyft开源的微服务管理、保护和监控框架。istio的基本框架如下所示：

![img](https://jimmysong.io/kubernetes-handbook/images/istio-mindmap.png)

<br>

## **istio的架构设计**
---

istio服务网格从逻辑上分为`数据平面`和`控制平面`。
* 数据平面由一组智能代理（Envoy）组成，被部署为sidecar。协调和控制所有服务之间的通信网络
* 控制平面管理并配置代理来进行流量路由，以及在运行时执行的策略。

下图展示了组成每个平面的不同组件：

![img](https://jimmysong.io/kubernetes-handbook/images/istio-mesh-arch.png)

<br>

## **istio特性**
---

* 流量管理：控制服务之间的流量和API调度流，使调用更加方便，增强不同环境下的网络鲁棒性
* 可观测性：连接服务之间的依赖关系和它们之间的性质和流量，提供快速识别定位问题的能力
* 策略实施：通过配置mesh而不是改变代码的方式来控制服务之间的访问策略
* 服务识别和安全：提供在mesh里的服务可识别性和安全性保护

<br>

## **istio设计目标**
---

几个关键的设计目标形成了istio的架构。这些目标对于使系统能够大规模和高性能地处理服务是至关重要的。

* **透明度最大化**：为了采用istio，运维人员或开发人员需要做尽可能少的工作，才能从系统中获得真正的价值。为此，istio可以自动将自己注入到服务之间的所有网络路径中。istio使用sidecar代理来捕获流量，并在可能的情况下，在不更改已部署的应用程序代码的情况下，自动对网络层进行配置，以实现通过这些代理来路由流量。在kubernetes中，代理被注入到pod中，通过编写iptables规则来捕获流量。一旦sidecar代理被注入以及流量路由被编程，istio就可以协调所有的流量。这个原则也适用于性能。当将istio应用于部署时，运维人员会看到所提供功能的资源成本增加地最小。组件和 API 的设计必须考虑到性能和可伸缩性。
* **可扩展性**：随着运维人员和开发人员越来越依赖于 Istio 提供的功能，系统必须随着他们的需求而增长。当我们继续添加新特性时，最大的需求是扩展策略系统的能力，与其他策略和控制源的集成，以及将关于网格行为的信号传播到其他系统进行分析的能力。策略运行时支持用于接入其他服务的标准扩展机制。此外，它允许扩展其词汇表，允许根据网格生成的新信号执行策略。
* **可移植性**：使用istio的生态系统在许多方面都有所不同。istio必须在任何云环境或本地环境中通过最小的努力就能运行起来。将基于istio的服务移植到新环境的任务必须是容易实现的。使用istio，您可以操作部署到多个环境中的单个服务。例如，可以在多个云上部署来实现冗余。
* **策略一致性**：将策略应用于服务之间的 API 调用提供了对网格行为的大量控制。然而，将策略应用在区别于 API 层上的资源也同样重要。例如，在机器学习训练任务消耗的 CPU 数量上应用配额比在发起任务的请求调用上应用配额更有用。为此，Istio 使用自己的 API 将策略系统维护为一个独立的服务，而不是将策略系统集成到 sidecar 代理中，从而允许服务根据需要直接与之集成。

<br>

## **Envoy**
---

istio使用Envoy代理的扩展版本，该代理是以c++开发的高性能代理，用于调解服务网格中所有服务的所有入站和出站流量。

Envoy代理被部署为服务的sidecar，在逻辑上为服务增加了Envoy的许多内置特性，例如：
* 动态服务发现
* 负载均衡
* TLS终端
* HTTP/2与gRPC代理
* 熔断器
* 健康检查
* 基于百分比流量分割的分阶段发布
* 故障注入
* 丰富的指标

Envoy在Pod中以sidecar模式部署。这允许istio将大量关于流量行为的信号作为属性提取出来，并发送给监控系统以提供有关整个服务网格的行为信息。sidecar代理模型还允许你将istio功能添加到现有部署中，无需重新构建或重写代码。

<br>

## **Pilot**
---

Pilot为Envoy sidecar提供服务发现、用于智能路由的流量管理功能（例如，A/B测试、金丝雀发布等）以及弹性功能（超时、重试、熔断器等）。

Pilot将控制流量行为的高级路由规则转化为特定于环境的配置，并在运行时将它们传递给Envoy。

<br>

## **Citadel**
---

Citadel通过内置的身份和证书管理，可以支持强大的服务间以及最终用户的身份验证。您可以使用Citadel来升级服务网格中的未加密流量。使用Citadel，operator可以执行给予服务身份的策略，而不是相对不稳定的3层或4层网络标识。从0.5版开始，您可以使用istio的授权特性来控制

<br>

## **Galley**
---

Galley是istio的配置验证、提取、处理和分发组件。它负责将其余的istio组件从底层平台（例如kubernetes）获取用户配置的细节隔离开来。

<br>

## **sidecar模式**
---

在软件架构中，sidecar连接到父应用并且为妻添加扩展或者增强功能。sidecar应用与主应用程序松散耦合。它可以屏蔽不同编程语言的差异，统一实现微服务的可观察性、监控、日志记录、断路器等功能。

![img](https://jimmysong.io/kubernetes-handbook/images/sidecar-pattern.jpg)

**使用sidecar模式的优势**
* 将与应用业务逻辑无关的功能抽象到共同基础设施，降低了微服务代码的复杂度
* 因为不再需要编写相同的第三方组件配置文件和代码，所以能够降低微服务框架中的代码重复度
* sidecar可以独立升级，降低应用程序代码和底层平台的耦合度

<br>

## **发现选择器**
---

发现选择器是istio 1.10引入的新功能之一。发现选择器允许我们控制istio控制平面观察和发送配置更新的命名空间。

在默认情况下，istio控制平面会观察和处理集群中的所有kubernetes资源的更新。服务网格中的所有默认Envoy代理的配置方式是，它们可以到达服务网格中的每个工作负载，并接受工作负载相关的所有端口的流量。

例如，我们在不同的namespace上部署了两个工作负载--foo和bar。尽管我们知道foo永远不会与bar通信，但一个服务的endpoint将被包含在另一个服务的已发现端点列表中。

其实发现选择器就是就是利用了matchLabels来做服务发现和注册，istio可以利用标签做到只观察自己关心的服务列表，而不再需要观察全部的kubernetes资源。我们可以更新IstioOperator以包括discoverySelectors字段：

```yaml
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
metadata:
  namespace: istio-system
  name: istio-demo
spec:
  meshConfig:
    discoverySelectors:
    - matchLabels:
        env: test
```

现在如果我们给foo命名空间贴上`env=test`的标签，然后列出端点，就会发现没有bar namespace下的endpoint了

<br>